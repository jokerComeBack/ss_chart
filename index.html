<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
      #container{
        position: relative;
        z-index: 100;
      }
      .box{
        /* padding-left: 100px; */
        /* padding-top: 100px; */
      }
        #tooltip{
          width: 120px;
          height: 50px;
          /* background-color: blue; */
          position: absolute;
          /* visibility: hidden; */
          z-index: 8;
          top: 0px;
          left: 0px;
          transition: left 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s, top 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s;
          background-color: rgb(255, 255, 255);
          box-shadow: rgb(174 174 174) 0px 0px 10px;
          border-radius: 3px;
          color: rgb(89, 89, 89);
          font-size: 12px;
          line-height: 12px;
          padding: 6px 12px;
          opacity: 0.95;
          box-sizing: border-box;
        }
        #location{
          
        }
        #message{
          display: flex;
          padding-top: 10px;
        }
        #icon{
          display: block;
          width: 10px;
          height: 10px;
          border-radius: 50%;
          /* background-color:green; */
        }
        #type{
          padding-left: 4px;
        }
        #data{
          padding-left: 20px;
        }
        
    </style>
</head>
<body>
    <div class='box'>
      <div id='container'></div>
    </div>
<script>
const colorArr = [{ dark: 'rgba(131, 215, 174, 1)', light: 'rgba(131, 215, 174, 0.4)' }, { dark: 'rgba(107, 151, 242, 1)', light: 'rgba(107, 151, 242, 0.4)' }];

class ssCanvas {
  constructor(props) {
    const {
      id,
      width,
      height,
      colors = '#6b97f2',
    } = props;
    // container.appendChild(canvasInstance1)
    this.id = id;
    this.width = width;
    this.height = height;
    this.colors = colors;
    this.cylinderWidth = 60;//定义柱状图宽度
    this.legendWidth = 10;
    this.legendHeight = 10;
    this.paddingBottom = 100;
    this.totalPath = [];
    this.legendPath = [];
	  const container = document.getElementById('container');
    container.style.position = 'relative';
    container.style.width = width + 'px';
    container.style.height = height + 'px';
    container.addEventListener('click', ()=>{
      console.log(123)
    })
    const ssCanvas = document.createElement('canvas');
    ssCanvas.id = 'ss_canvas';
    container.appendChild(ssCanvas);
    const tooltipDiv = document.createElement('div');
    tooltipDiv.className = 'tooltip';
    const tooltipDiv2 = this.tooltipTemplate();
    tooltipDiv.innerHTML = tooltipDiv2;
    container.appendChild(tooltipDiv);
    this._canvas = document.getElementById(ssCanvas.id);
    this._canvas.width = this.width;
    this._canvas.height = this.height;
  }

  tooltipTemplate(){
    return `<div id='tooltip'>
          <div id='location'>北京</div>
          <div id='message'>
            <i id='icon'></i>
            <span id='type'>男</span>
            <span id='data'>100</span>
          </div>
      </div>`
  }
  buildData(data) {
    this.originData = data;
	  this.maxData = 0;
    const newData = data.reduce((total, current) => {
      if (Array.isArray(total[current.location])) {
        total[current.location].push(current);
      } else {
        total[current.location] = [current];
      }
      return total;
    }, {});
    this.data = Object.values(newData);
	// 计算 Y 轴最大的数字
	this.maxData = this.data.reduce((total, current)=>{
		let currentData = eval(current.map(item=>item.data).join('+'))
		let maxData = Math.max(currentData, total);
		return maxData;
	}, 0)
	// 计算 Y 轴的缩放比例
	const scaleY = this.height / this.maxData;
	this.scale = {
		x: 1,
		y: scaleY
	}
	this.data = this.data.map(item=>{
		const newItem = item.map(innerItem=>{
			return {
				...innerItem,
				data: innerItem.data * scaleY
			}
		})
		return newItem;
	})
    this.legend = this.data[0];
  }

  render() {
    this.cols = (this.width - this.cylinderWidth - 30) / this.data.length;//逐个柱子占位宽度和间距共90
    this.ctx = this._canvas.getContext('2d');
    this.drawRows();
    this.drawRects({});
    this.drawLegend({});
    this._canvas.addEventListener('click', (e) => {
      const ctx = this.ctx;
      let clickItem = '';
      ctx.clearRect(0, 0, this.width, this.height);
      this.legendPath.forEach(item => {
        ctx.beginPath();
        ctx.rect(
          ...item.path
        );
        const canvasInfo = this._canvas.getBoundingClientRect();
        const isInrect = ctx.isPointInPath(e.clientX - canvasInfo.left, e.clientY - canvasInfo.top);
        if (isInrect) {
          clickItem = item;
        }
      });
      this.drawRows();
      this.drawLegend(clickItem);
      this.drawRects({ clickItem });
    });
    this._canvas.addEventListener('mousemove', (e) => {
      const ctx = this.ctx;
      let hoverType = '';
      let hoverRectItem = {};
      let hoverLegendStyle = 'default';
      ctx.clearRect(0, 0, this.width, this.height);
      this.totalPath.forEach(item => {
        ctx.beginPath();
        ctx.rect(
          ...item.path
        );
        const canvasInfo = this._canvas.getBoundingClientRect();
        const isInrect = ctx.isPointInPath(e.clientX - canvasInfo.left, e.clientY - canvasInfo.top);
        if (isInrect) {
          hoverType = item.type;
          hoverRectItem = item;
        }
      });
      this.legendPath.forEach(item => {
        ctx.beginPath();
        ctx.rect(
          ...item.path
        );
        const canvasInfo = this._canvas.getBoundingClientRect();
        const isInrect = ctx.isPointInPath(e.clientX - canvasInfo.left, e.clientY - canvasInfo.top);
        if (isInrect) {
          hoverLegendStyle = 'pointer';
        }
      });
      this._canvas.style.cursor = hoverLegendStyle;
      this.drawRows();
      this.drawRects({ hoverType });
      this.drawLegend({});
      this.drawTooltip(e, hoverRectItem)
    });
  }
  drawTooltip(e, hoverRectItem){
     const tooltip = document.getElementById('tooltip');
     
    if(hoverRectItem.location){
      const {
        location,
        color,
        type,
        data
      } = hoverRectItem
      document.getElementById('location').innerHTML = location;
      document.getElementById('type').innerHTML = type;
      document.getElementById('data').innerHTML = data;
      document.getElementById('icon').style.background = color;
      tooltip.style.visibility = 'visible';
      tooltip.style.top = e.clientY + 'px'
      tooltip.style.left = e.clientX + 'px'
    }else{
      tooltip.style.visibility = 'hidden';
    }
    

  }
  drawLegend(clickItem) {
    const legendCols = (this.width - this.legendWidth - this.width / (this.legend.length + 2)) / this.legend.length;
    const ctx = this.ctx;
    for (let i = 0; i < this.legend.length; i++) {
      const {
        type
      } = this.legend[i];
      ctx.beginPath();
      const path = [(i + 1) * legendCols, this._canvas.height - this.paddingBottom / 2, 10, 10];
      const show = !(clickItem.type === type && clickItem.show);
      this.legendPath.push({ path, type, show });
      ctx.fillStyle = show ? colorArr[i].dark : colorArr[i].light;
      ctx.rect(
        ...path
      );

      ctx.fill();
      ctx.font = '10px scans-serif';
      ctx.fillStyle = '#000';
      const text = ctx.measureText(type);
      ctx.fillText(type, (i + 1) * legendCols + 15, this._canvas.height - this.paddingBottom / 2 + 8);//
      ctx.closePath();
    }
  }

  drawBackGround(item, sert) {
    const ctx = this.ctx;
    const backGroundPath = [item[0] - 10, this._canvas.height - this.max - this.paddingBottom, this.cylinderWidth + 20, this.max];
    ctx.beginPath();
    ctx.rect(
      ...backGroundPath
    );//横坐标为90的倍数，纵坐标为画布高度减去柱子高度
    ctx.fillStyle = '#f0f3f8';
    ctx.fill();
    ctx.closePath();
    this.drawRows();
    this.drawRects({});
  }

  drawRects({ hoverType, clickItem = {} }) {
    const ctx = this._canvas.getContext('2d');
    const { data, cols, cylinderWidth } = this;
    for (let i = 0; i < data.length; i++) {
      let totalData = 0;
      const dataItem = data[i];
      if (Array.isArray(dataItem)) {
        for (let j = 0; j < dataItem.length; j++) {
          const {
            data,
            type,
            location
          } = dataItem[j];
          //绘制柱状图
          const newData = type === clickItem.type && clickItem.show === true ? 0 : data;
          totalData += newData;
          ctx.beginPath();

          if (hoverType && hoverType !== type) {
            ctx.lineWidth = 0;
            ctx.fillStyle = colorArr[j].light;
          } else {
            ctx.fillStyle = colorArr[j].dark;
          }
          const path = [(i + 1) * cols, this._canvas.height - totalData - this.paddingBottom, cylinderWidth, newData];
          this.totalPath.push({ ...dataItem[j], path, color: colorArr[j].dark });
          ctx.rect(
            ...path
          );//横坐标为90的倍数，纵坐标为画布高度减去柱子高度

          ctx.fill();
          //绘制柱状图顶部数值
          ctx.font = '14px scans-serif';
          ctx.fillStyle = '#9f9f9f';
          const text = ctx.measureText(location);
          if (j === 0) {
            ctx.fillText(location, (i + 1) * cols + (cylinderWidth - text.width) / 2, this._canvas.height - this.paddingBottom + 20);
          }
          ctx.closePath();
          ctx.stroke();
        }
      }
    }
  }
  drawRows(rows = 4) {
    const ctx = this._canvas.getContext('2d');
    // 算出 Y轴的区间高
    const rowHeight = Math.floor((this.height - this.paddingBottom) / rows);
    const scaleInterval = Math.floor((this.maxData - this.paddingBottom) / rows);
	// 计算 y 轴文案的最大宽度
    for (let i = 0; i < rows; i++) {
      ctx.beginPath();
	    ctx.font = '15px scans-serif';
      ctx.fillStyle = '#8c8c8c';
	    const maxYWidth = ctx.measureText(this.maxData);
      const colsNo = ctx.measureText(i * scaleInterval);//设置好字体才能计算字体宽度
      ctx.fillText(i * scaleInterval, maxYWidth.width - colsNo.width, this._canvas.height - i * rowHeight - this.paddingBottom);
      //绘制行
      ctx.moveTo(maxYWidth.width, this._canvas.height - i * rowHeight - this.paddingBottom);
      ctx.lineTo(this._canvas.width, this._canvas.height - i * rowHeight - this.paddingBottom);
      ctx.strokeStyle = '#d9d9d9';
      //绘制坐标点
      if (i === rows - 1) {
        this.max = i * rowHeight;
      }
      ctx.closePath();
      ctx.stroke();
    }
  }
}

const data = [
  {
    location: '北京',
    data: 450,
    type: '图例 1'
  },
  {
    location: '北京',
    data: 550,
    type: '图例 2'
  },
  {
    location: '上海',
    data: 55,
    type: '图例 1'
  },
  {
    location: '上海',
    data: 65,
    type: '图例 2'
  },
  {
    location: '深圳',
    data: 60,
    type: '图例 1'
  },
  {
    location: '深圳',
    data: 60,
    type: '图例 2'
  },
  {
    location: '成都',
    data: 110,
    type: '图例 1'
  },
  {
    location: '成都',
    data: 120,
    type: '图例 2'
  }
];
const newCanvas = new ssCanvas({
  id: 'container',
  height: 500,
  width: 800,
});
newCanvas.buildData(data);
newCanvas.render();
	
</script>
</body>
</html>